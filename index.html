<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Why Unit Tests?</h2>
					<ul>
						<li>Prevent production bugs - Improve developer productivity (long term) - Fixing bugs interrupts the normal flow of software development, which causes context switching</li>
						<li>Design aid: Writing tests first gives you a clearer perspective on the ideal API design. it forces you to have a direction in mind before you start charging into the fray, and having a direction in mind leads to better designs</li>
						<li>Feature documentation & test of developer understanding: The test should provide a clear description of the feature being tested.</li>
					</ul>	
					<p>It’s when you’re refactoring, i.e., restructuring a unit’s code but without meaning to change its behaviour. In this case, unit tests can often tell you if the unit’s behaviour has changed</p>				
					<p>TDD is a robust way of designing software components (“units”) interactively so that their behaviour is specified through unit tests.</p>
				</section>
				<section>
					<h2>How Unit Tests?</h2>
					<p>Most developers seem to agree that testing is good, but developers frequently disagree about how to test.</p>
				</section>
				<section>
					<h2>Approaches</h2>
					<p>Testing state - involves performing an action on a unit and then checking that either an expected result was returned, or the state of the unit has been updated as expected. Testing state can be achieved regardless of if you are white box or black box testing.</p>
					<p>Testing implementation is an extension to white box testing where you check that certain methods are invoked or not during the execution of an action. Here you don’t assert any state, but instead verify that internal behavior is doing what is expected.</p>
				</section>
				<section>
						<h2>The anatomy of a unit test</h2>

						A single unit test that asserts state is typically made up of the following three stages:
						
						‘Arrange’ gets everything ready to perform the test. This could be declaring variables, building required objects or setting the state of a unit based on the circumstances we want to test. Some or all of this step could take place in the SetUp method of the current unit testing fixture. For simple unit tests, this step may not be needed.
						‘Act’ performs the action that we are testing on the unit.
						‘Assert’ checks to see that the action performed correctly. We want to check that either the return value of a method call is expected, or the state of an object is as expected.
				</section>
				<section>
					<h2>Guidelines</h2>
					This could be a series of workshops.
					The goal of these guidelines is to make your tests:

Readable
Maintainable
Trustworthy
				</section>

				<section>
					<h2>Make each test independent</h2>
					<p>Order of test should not matter</p>
					<p>Mock out all external services and state - but mock only those who can couse shared state/side effects</p>
				</section>

				<section>
					<h2>Don't make unnecessary assertions</h2>
					<p>Keep the number of assertions per unit test to a minimum. 
						A single unit test is testing one thing. 
						Multiple assertions in a single test are fine, 
						but if it’s logical to split the assertions into separate tests, 
						then it’s best to do so.</p>
						<p>Sometimes, TDD folks express this by saying "*have only one logical assertion per test*". Remember, unit tests are a design specification of how a certain behaviour should work, not a list of observations of *everything* the code happens to do.</p>

				</section>

				<section>
					<h2>Avoid unnecessary preconditions</h2>
					<p>Avoid having common setup code that runs at the beginning of lots of unrelated tests. Otherwise, it's unclear what assumptions each test relies on, and indicates that you're not testing just a single unit.</p>
				</section>

				<section>
					<h2>Name your unit tests clearly and consistently</h2>
					<p>Tests names should be concise, explicit, descriptive</p>
					<p>S/S/R - This name describes the **subject** (ProductController's Purchase action), the **scenario** (stock is zero), and the **result** (renders "out of stock" view).</p>
					<pre><code>
describe('[unit of work]', () => {
	describe('when [scenario/context]', () => {
		it('should [expected behaviour]', () => {
		});
	});
});

					</code></pre>
				</section>

				<section>
					<h2>Assertions should be situated in the unit tests proper, rather than pulled out into helper methods.</h2>
					<p>It increases the readability</p>
				</section>

				<section>
					<h2>Don't comment tests</h2>
					<p>If they are unclear or complex it's better to remove them</p>
				</section>

				<section>
					<h2>Avoid logic in your tests</h2>
					<p>avoid loops and if conditionals</p>
					<p>Conditionals: you don't know which path the test will take
							Loops: you could be sharing state between tests</p>
				</section>

				<section>
					<h2>Consider using factory functions in the tests</h2>
					<p>Factories can:

							help reduce the setup code, especially if you use dependency injection
							make each test more readable, since the creation is a single function call that can be in the test itself instead of the setup
							provide flexibility when creating new instances (setting an initial state, for example)</p>
				</section>

				<section>
					<h2>Know your tools</h2>
					<p>fit, .only, different assertions</p>
				</section>

				<section>
					<h2>Cover the general case and the edge cases</h2>
				</section>

				<section>
					<h2>Minimal and Meaningless data</h2>
					<p>It's common to find unit tests in which the data passed to and expected from the subject appear like it might be special.</p>
				</section>

				<section>
					<h2>Keep the test suite consistent</h2>
					<p>Specially for teams</p>
					<p>Avoid Accidental Creativity - Interpreting the author's intent when reading a test is often made unnecessarily challenging when the structure and form of each test varies arbitrarily</p>
				</section>

				<section>
					<h2>Don't mock everything</h2>
					<p>Don't mock what you don't own</p>
				</section>

				<section>
					<h2>Template</h2>
					<pre><code>
test('What component aspect are you testing?', assert => {
	const actual = 'What is the actual output?';
	const expected = 'What is the expected output?';

	assert.equal(actual, expected,
		'What should the feature do?');

	assert.end();
});
					</code></pre>
				</section>
				<section>
					<h2>Final thoughts</h2>
				</section>
				<section>
					<h2>Any Unit Test is better than none?</h2>
					<p>A suite of good unit tests is immensely valuable: it documents your design, and makes it easier to refactor and expand your code while retaining a clear overview of each component’s behaviour. However, a suite of bad unit tests is immensely painful: it doesn’t prove anything clearly, and can severely inhibit your ability to refactor or alter your code in any way.</p>
				</section>
				<section>
					<h2>Unit Tests vs Integration/Functional</h2>
					<p>Proving that components X and Y both work independently doesn’t prove that they’re compatible with one another or configured correctly.</p>
					<img src="https://cdn-images-1.medium.com/max/800/0*eCs8GoVZVksoQtQx.gif" alt="">
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
